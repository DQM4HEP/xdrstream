  /// \file IODevice.h
/*
 *
 * IODevice.h header template automatically generated by a class generator
 * Creation date : dim. janv. 17 2016
 *
 * This file is part of xdrstream libraries.
 * 
 * xdrstream is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * xdrstream is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with xdrstream.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef IODEVICE_H
#define IODEVICE_H

#include "xdrstream/XdrDefinitions.h"

namespace xdrstream
{

class Record;
class Block;

/** 
 *  @brief  IODevice class
 */
class IODevice
{
public:
	/**
	 *  @brief  Constructor
	 */
	IODevice();

	/**
	 *  @brief  Destructor
	 */
	virtual ~IODevice();

	/**
	 *  @brief  Whether the device is opened
	 */
	virtual bool isOpened() const = 0;

	/**
	 *  @brief  Reset the device
	 */
	virtual Status reset() = 0;

	/**
	 *  @brief  Whether the device is readable
	 */
	virtual bool isReadable() const = 0;

	/**
	 *  @brief  Whether the device is writable
	 */
	virtual bool isWritable() const = 0;

	/**
	 *  @brief  Get the device contents size
	 */
	virtual xdr_size_t size() const = 0;

	/**
	 *  @brief  Get the cursor position in the device
	 */
	virtual xdr_size_t getPosition() const = 0;

	/**
	 *  @brief  Seek the cursor in the device at the specified location
	 *
	 *  @param  position the position to point to in the device
	 */
	virtual Status seek(xdr_size_t position) = 0;

	/**
	 *  @brief  Read a single value (int, float, ...)
	 *
	 *  @param  pAddress the address of the single value to read
	 *  @param  dataSize the size of the single value in memory (use sizeof(val))
	 */
	virtual Status readData(void *pAddress, xdr_size_t dataSize) = 0;

	/**
	 *  @brief  Read a c-string array from the device.
	 *          An array of size strLen+1 is allocated using new operator
	 *          and the last character of the string is set to '\0' null character.
	 *          To write a c-string into the device, use writeArray(pCString, strLen)
	 *
	 *  @param  pCString the address of the c-string to read
	 *  @param  strLen the length of the c-string (strLen+1 with '\0' char at the end)
	 */
	virtual Status readCString(char *&pCString, xdr_size_t &strLen) = 0;

	/**
	 *  @brief  Read a fixed size data array.
	 *          The array has to be allocate before calling this function
	 *
	 *  @param  pAddress the address of the array
	 *  @param  arraySize the number of element to read in the array
	 *  @param  elementSize the size in memory of a single element
	 */
	virtual Status readStaticArray(void *pAddress, xdr_size_t arraySize, xdr_size_t elementSize) = 0;

	/**
	 *  @brief  Read a fixed size data array.
	 *          The array is allocate in this function using new operator.
	 *          The array size is read from the device and returned by reference.
	 *
	 *  @param  pAddress the address of the array
	 *  @param  arraySize the number of element read from the device (returned by reference)
	 *  @param  elementSize the size in memory of a single element
	 *  @param  allocator the allocator function that will perform the memory allocation for the array
	 */
	virtual Status readDynamicArray(void *&pAddress, xdr_size_t &arraySize, xdr_size_t elementSize, xdr_allocator allocator) = 0;

	/**
	 *  @brief  Write a single value (int, float, ...)
	 *
	 *  @param  pAddress the address of the single value to write
	 *  @param  dataSize the of the single value in memory (use sizeof(val))
	 */
	virtual Status writeData(const void *pAddress, xdr_size_t dataSize) = 0;

	/**
	 *  @brief  Write array in the device
	 *
	 *  @param  pAddress the address of the array to write
	 *  @param  arraySize the number of element to write in the device
	 *  @param  elementSize the size of a single element in memory (use sizeof(val))
	 */
	virtual Status writeArray(const void *pAddress, xdr_size_t arraySize, xdr_size_t elementSize) = 0;

	/**
	 *  @brief  Write n empty bytes in the device
	 *          In read mode, just skip bytes using seek(current + nBytes)
	 *
	 *  @param  nBytes the number of empty bytes to write in the device
	 */
	virtual Status writeEmptyBytes(xdr_size_t nBytes) = 0;

protected:
	/**
	 *  @brief  Read/write the record header in the device
	 *
	 *  @param  mode the streaming mode (read or write)
	 *  @param  recordHeader the record header to read/write
	 */
	virtual Status recordHeader(StreamingMode mode, Header &recordHeader) = 0;

	/**
	 *  @brief  Read/write the block header in the device
	 *
	 *  @param  mode the streaming mode (read or write)
	 *  @param  blockHeader the block header to read/write
	 */
	virtual Status blockHeader(StreamingMode mode, Header &blockHeader) = 0;

public:
	/**
	 *  @brief  Read a single value from the device
	 *
	 *  @param pValue the address of the variable to read
	 */
	template <typename T>
	Status read(T *pValue);

	/**
	 *  @brief  Read an array from the device.
	 *          The array has to allocated before calling this function.
	 *
	 *  @param  pValue the address of the static array
	 *  @param  size the array length
	 */
	template <typename T>
	Status readStaticArray(T *pValue, xdr_size_t arraySize);

	/**
	 *  @brief  Read an array from the device.
	 *          The array is allocated in the function using new operator
	 *
	 *  @param  pValue the reference pointer of the array to receive
	 *  @param  size the array length to receive
	 */
	template <typename T>
	Status readDynamicArray(T *&pValue, xdr_size_t &arraySize);

	/**
	 *  @brief  Read the address from the device
	 *
	 *  @param  pAddress the address pointer to receive
	 */
	Status readAddress(void *&pAddress);

	/**
	 *  @brief  Read a pointer tag from the device
	 *          The old address is read from the device and stored
	 *          in the pointer map with the new address for a future relocation
	 *
	 *  @param  pNewAddress the address of the new created object
	 */
	Status readPointerTag(void *pNewAddress);

	/**
	 *  @brief  Read a pointer reference from the device
	 *          The old address is read from the device and stored
	 *          in the pointer map with the new destination address
	 *          for a future relocation
	 *
	 *  @param  pDestination the address of the pointer (pointer to pointer) that will reference
	 *          an object after pointer relocation
	 */
	Status readPointerReference(void **pDestinationAddress);

	/**
	 *  @brief  Write a single value into the device
	 *
	 *  @param  pValue the address of value to write
	 */
	template <typename T>
	Status write(const T *pValue);

	/**
	 *  @brief  Write an array into the device
	 *
	 *  @param  pArray the address of the array to write
	 *  @param  arraySize the array length
	 */
	template <typename T>
	Status writeArray(const T *pArray, xdr_size_t arraySize);

	/**
	 *  @brief  Write address into the device.
	 *          The address is converted to int 64 before writing
	 *
	 *  @param  pAddress the address to write
	 */
	Status writeAddress(const void *pAddress);

	/**
	 *  @brief  Write a pointer tag into the device
	 *
	 *  @param  pAddress the address to write
	 */
	Status writePointerTag(const void *pAddress);

	/**
	 *  @brief  Write a pointer reference into the device
	 *
	 *  @param  pAddress the address to write
	 */
	Status writePointerReference(const void *pAddress);

protected:
	/**
	 *  @brief  Call back function called at start of record streaming
	 *
	 *  @param  mode the streaming mode (read or write)
	 *  @param  pRecord the record address
	 */
	virtual Status startOfRecord(StreamingMode mode, Record *pRecord);

	/**
	 *  @brief  Call back function called at end of record streaming
	 *
	 *  @param  mode the streaming mode (read or write)
	 *  @param  pRecord the record address
	 */
	virtual Status endOfRecord(StreamingMode mode, Record *pRecord);

	/**
	 *  @brief  Call back function called at start of block streaming
	 *
	 *  @param  mode the streaming mode (read or write)
	 *  @param  pBlock the block address
	 */
	virtual Status startOfBlock(StreamingMode mode, Block *pBlock);

	/**
	 *  @brief  Call back function called at end of block streaming
	 *
	 *  @param  mode the streaming mode (read or write)
	 *  @param  pBlock the block address
	 */
	virtual Status endOfBlock(StreamingMode mode, Block *pBlock);

	/**
	 *  @brief  Perform pointer relocation
	 */
	Status performPointerMapping();

private:
	PointerMapper                         *m_pPointerMapper;       ///< The pointer mapping interface for pointer relocation

	friend class Record;
	friend class XdrStream;
};

//----------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------

template <typename T>
inline Status IODevice::read(T *pValue)
{
	return this->readData( (void *) pValue, sizeof(T));
}

//----------------------------------------------------------------------------------------------------

template <typename T>
inline Status IODevice::readStaticArray(T *pValue, xdr_size_t arraySize)
{
	return this->readStaticArray( (void *) pValue, arraySize, sizeof(T));
}

//----------------------------------------------------------------------------------------------------

template <typename T>
inline Status IODevice::readDynamicArray(T *&pValue, xdr_size_t &arraySize)
{
	return this->readDynamicArray( (void *&) pValue, arraySize, sizeof(T), & xdr_allocator_helper<T>::alloc);
}

//----------------------------------------------------------------------------------------------------

template <typename T>
inline Status IODevice::write(const T *pValue)
{
	return this->writeData( (const void *) pValue, sizeof(T));
}

//----------------------------------------------------------------------------------------------------

template <typename T>
inline Status IODevice::writeArray(const T *pArray, xdr_size_t arraySize)
{
	return this->writeArray( (const void *) pArray, arraySize, sizeof(T));
}

//----------------------------------------------------------------------------------------------------

template <>
inline Status IODevice::read(std::string *pValue)
{
	xdr_size_t strLen;
	char *pStrBuffer = NULL;

	XDR_STREAM( this->readCString(pStrBuffer, strLen) )

	*pValue = pStrBuffer;
	delete [] pStrBuffer;

	return XDR_SUCCESS;
}

//----------------------------------------------------------------------------------------------------

template <>
inline Status IODevice::write(const std::string *pValue)
{
	return this->writeData( (const void *) pValue->c_str(), pValue->size());
}


} 

#endif  //  IODEVICE_H
